#!/usr/bin/env python
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------#
#                                    vimtmpl                                   #
#------------------------------------------------------------------------------#
"""vimtmpl, short description of script.

"""

__author__ = "John van Zantvoort"
__date__ = "21-Jun-2016"

__license__ = "MIT"
__version__ = "1.0.1"
#------------------------------------------------------------------------------#
#------------------------------------------------------------------------------#

import sys
import os
import string
from time import localtime, gmtime, strftime
import argparse
import pwd
import pprint
import re
import ConfigParser

class TemplateWorker(object):

    def __init__(self, executable, *dirnames):
        self.executable = executable
        self.dirname = 'vimtmpl'
        self.dirnames = list()
        self.templatesdir = os.path.expanduser('~/.tools/templates')

        for dirname in dirnames:
            dirname = os.path.expanduser(dirname)
            if os.path.isabs(dirname):
                self.dirnames.append(dirname)
                continue

            if os.sep not in dirname:
                self.dirnames.append(os.path.join(self.templatesdir, dirname))
                continue

            _dirnames = dirname.split(os.sep)
            dirname = os.path.join(self.templatesdir, *_dirnames)
            self.dirnames.append(dirname)

        self.dirnames.append(os.path.expanduser('~/.tools/templates/local'))
        self.dirnames.append(os.path.expanduser('~/.tools/templates/default'))

    def tmpl_path(self, dirn):
        return os.path.join(dirn, self.executable + ".template")

    def has_template(self, dirn):
        if os.path.exists(self.tmpl_path(dirn)):
            return True
        return False

    def get_template(self):
        for x in self.dirnames:
            if self.has_template(x):
                return string.Template(open(self.tmpl_path(x)).read())

    def __call__(self, **kwargs):
        data = self.get_template()
        info = dict()
        for k, v in kwargs.iteritems():
            info[k] = v
        info['date'] = strftime('%d-%b-%Y',localtime())
        info['year'] = strftime('%Y',localtime())
        info['user'] = pwd.getpwuid(os.getuid()).pw_gecos
        info['username'] = pwd.getpwuid(os.getuid()).pw_name
        try:
            scripttext = data.safe_substitute(info)
        except AttributeError:
            scripttext = 'Error: have no template data for {0}'.format(self.executable)
        return scripttext

def parse_args(args):
    """
    Parse command line parameters

    :param args: command line parameters as list of strings
    :return: command line parameters as :obj:`argparse.Namespace`
    """
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--version',
        action='version',
        version='$scriptname {ver}'.format(ver=__version__))

    parser.add_argument(
        '-w',
        '--write',
        action='store_true',
        help="write the file")

    parser.add_argument(
        '-d',
        '--description',
        help="description of the script")

    parser.add_argument(
        '-t',
        '--templates',
        dest='tdirs',
        action='append',
        help="location of the templates")

    parser.add_argument('scriptpath', nargs='*')


    opts = vars(parser.parse_args(args))
    opts = {k: v for k, v in opts.items() if v is not None}

    opts['scriptpath'] = " ".join(opts['scriptpath'])
    opts['scriptname'] = os.path.basename(opts['scriptpath'])

    if 'write' not in opts:
        opts['write'] = False

    return {k: v for k, v in opts.items() if v is not None}

def write(args, content):
    filepath = args['scriptpath']

    if os.path.exists(filepath):
        raise IOError(17, 'file {0} already exists'.format(filepath))

    ofh = open(filepath, 'w')
    ofh.write(content)
    ofh.close()
    os.chmod(filepath, 0755)

argdict = parse_args(sys.argv[1:])

executable = re.sub(r'^.*vimtmpl_', '', sys.argv[0])

try:
    config = ConfigParser.ConfigParser()
    config.read(os.path.expanduser('~/.vimtmplrc'))
    if config.has_section('user'):
        if config.has_option('user', 'mailaddress'):
            argdict['mailaddress'] = config.get('user', 'mailaddress')
        if config.has_option('user', 'company'):
            argdict['company'] = config.get('user', 'company')
    if config.has_section(executable):
        for opt in config.options(executable):
            argdict[opt] = config.get(executable, opt)

except:
    pass

tdirs = list()
if 'tdirs' in argdict:
    tdirs = argdict['tdirs']

tmpl = TemplateWorker(executable, *tdirs)

if argdict['write']:
    try:
        write(argdict, tmpl(**argdict))
    except IOError as ioerr:
        ioerrno = ioerr[0]
        ioerrmsg = ioerr[1]
        if ioerrno in [13]:
            print "%s on %s" % (ioerrmsg, argdict['scriptpath'])
        else:
            print ioerrmsg
        sys.exit(ioerrno)

else:
    print tmpl(**argdict)
